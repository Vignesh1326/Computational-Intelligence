# -*- coding: utf-8 -*-
"""CSE18163_CI_ASSIGN2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1eKP1yKjJISADvyJYEBwlJuTPdxdFdedx
"""

import tensorflow as tf
import numpy as np

#Callback function to stop the epoch/training the model when accuracy becomes 100%

class myCallback(tf.keras.callbacks.Callback):
  def on_epoch_end(self, epoch, logs={}):
    if(logs.get('binary_accuracy')==1.0):
      print("\n Training stopped! Reached 100% accuracy")
      self.model.stop_training = True

#Creating the model

model = tf.keras.Sequential([
    tf.keras.layers.Dense(16, activation='relu', input_shape=(2,)),
    tf.keras.layers.Dense(1, activation='sigmoid')
])
callbacks = myCallback()
model.compile(optimizer='adam', loss='mean_squared_error', metrics=['binary_accuracy'])

#XOR
x = np.array([[0, 0],[0, 1],[1, 0],[1, 1]],dtype = float)
y = np.array([[0],[1],[1],[0]],dtype=float)
model.fit(x,y,epochs=500,callbacks=[callbacks])
print()
print("The output of XOR gate is :")
print()
print('X1\t X2\t\ts\t     Y')
s = model.predict(x)
ans = model.predict(x).round()
for i in range(4):
  print(x[i][0],'\t',x[i][1],'\t   ',s[i][0],'\t   ',ans[i][0])

#AND
x = np.array([[0, 0], [0, 1], [1, 0], [1, 1]], dtype=float)
y = np.array([[0], [0], [0], [1]], dtype=float)
model.fit(x, y, epochs=500, callbacks=[callbacks])
print()
print("The output for AND gate is: ")
print()
print('X1\t X2\t    s\t\t    Y')
s = model.predict(x).round()
ans = model.predict(x).round()
for i in range(4):
  print(x[i][0],'\t',x[i][1],'\t   ',s[i][0],'\t   ',ans[i][0])

#OR
x = np.array([[0, 0], [0, 1], [1, 0], [1, 1]], dtype=float)
y = np.array([[0], [1], [1], [1]], dtype=float)
model.fit(x, y, epochs=500, callbacks=[callbacks])
print()
print("The output for OR gate is: ")
print()
print('X1\t X2\t\ts\t    Y')
s = model.predict(x)
ans = model.predict(x).round()
for i in range(4):
  print(x[i][0],'\t',x[i][1],'\t   ',s[i][0],'\t   ',ans[i][0])

#NAND
x = np.array([[0, 0], [0, 1], [1, 0], [1, 1]], dtype=float)
y = np.array([[1], [1], [1], [0]], dtype=float)
model.fit(x, y, epochs=500, callbacks=[callbacks])
print()
print("The output for NAND gate is: ")
print()
print('X1\t X2\t\ts\t    Y')
s = model.predict(x)
ans = model.predict(x).round()
for i in range(4):
  print(x[i][0],'\t',x[i][1],'\t   ',s[i][0],'\t   ',ans[i][0])

#NOR
x = np.array([[0, 0], [0, 1], [1, 0], [1, 1]], dtype=float)
y = np.array([[1], [0], [0], [0]], dtype=float)
model.fit(x, y, epochs=500, callbacks=[callbacks])
print()
print("The output of NOR gate is: ")
print()
print('X1\t X2\t\ts\t    Y')
s = model.predict(x)
ans = model.predict(x).round()
for i in range(4):
  print(x[i][0],'\t',x[i][1],'\t   ',s[i][0],'\t   ',ans[i][0])

#XNOR
x = np.array([[0, 0], [0, 1], [1, 0], [1, 1]], dtype=float)
y = np.array([[1], [0], [0], [1]], dtype=float)
model.fit(x, y, epochs=500, callbacks=[callbacks])
print()
print("The output of XNOR gate is: ")
print()
print('X1\t X2\t\ts\t    Y')
s = model.predict(x)
ans = model.predict(x).round()
for i in range(4):
  print(x[i][0],'\t',x[i][1],'\t   ',s[i][0],'\t   ',ans[i][0])

#NOT
x = np.array([[0],[1]],dtype=float)
y = np.array([[1],[0]], dtype = float)
model.fit(x,y,epochs = 500,callbacks=[callbacks])
print()
print("The output of NOT gate is: ")
print()
print('X1\t\ts\t Y')
s = model1.predict(x)
ans = model1.predict(x).round()
for i in range(2):
  print(x[i][0],'\t',s[i][0],'\t',ans[i][0,])